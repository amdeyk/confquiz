{% extends "base.html" %}

{% block title %}Presenter Dashboard - Quiz System{% endblock %}

{% block content %}
<div class="presenter-container">
    <div class="header">
        <h1>üé• Presenter Dashboard</h1>
        <div class="header-actions">
            <span id="connectionStatus" class="status-badge disconnected">Disconnected</span>
            <button onclick="logout()" class="btn btn-secondary">Logout</button>
        </div>
    </div>

    <!-- Session Selection -->
    <div class="card">
        <h2>Select Session</h2>
        <select id="sessionSelect" class="form-control">
            <option value="">-- Select a session --</option>
        </select>
    </div>

    <!-- Help Instructions -->
    <div class="help-banner">
        <h3>üìñ Quick Start Guide</h3>
        <div class="help-steps">
            <div class="step">1Ô∏è‚É£ Select your session above</div>
            <div class="step">2Ô∏è‚É£ Open your PowerPoint presentation in full-screen mode</div>
            <div class="step">3Ô∏è‚É£ Click "Start Screen Sharing" and select the presentation window</div>
            <div class="step">4Ô∏è‚É£ Navigate slides using PowerPoint controls - they'll appear on the main display!</div>
            <div class="step">‚ö†Ô∏è Ensure at least 2 protected displays are approved before starting</div>
            <div class="step">üí° <strong>Tip:</strong> Use 10 FPS (recommended) or 15 FPS for maximum clarity</div>
        </div>
    </div>

    <!-- Screen Sharing Controls -->
    <div class="card">
        <h2>Screen Sharing</h2>
        <div id="notPresentingState">
            <p class="info-text">Share your screen to present PowerPoint slides to the display</p>
            <button id="startSharingBtn" class="btn btn-primary" onclick="startScreenShare()">
                üì∫ Start Screen Sharing
            </button>
            <div class="settings-row">
                <label>Frame Rate:</label>
                <select id="fpsSelect">
                    <option value="10" selected>10 FPS (Recommended)</option>
                    <option value="15">15 FPS (Highest clarity)</option>
                </select>
            </div>
        </div>

        <div id="presentingState" style="display: none;">
            <div class="presenting-indicator">
                <div class="pulse-dot"></div>
                <span>You are presenting</span>
            </div>
            <video id="localPreview" autoplay playsinline muted></video>
            <button id="stopSharingBtn" class="btn btn-danger" onclick="stopScreenShare()">
                ‚èπÔ∏è Stop Sharing
            </button>
            <div class="stats">
                <div>Frame Rate: <span id="currentFps">0</span> FPS</div>
                <div>Connected Displays: <span id="displayCount">0</span></div>
            </div>
            <div class="display-health">
                <h4>üì∫ Display Status</h4>
                <div id="displayHealthList"></div>
            </div>
        </div>
    </div>

    <!-- Browser Compatibility Warning -->
    <div id="compatibilityWarning" class="alert alert-warning" style="display: none;">
        ‚ö†Ô∏è Screen sharing is not supported in your browser. Please use Chrome, Firefox, or Edge.
    </div>
</div>

<style>
    .presenter-container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
    }

    .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 30px;
        padding-bottom: 20px;
        border-bottom: 2px solid #e0e0e0;
    }

    .header h1 {
        margin: 0;
        color: #2c3e50;
    }

    .header-actions {
        display: flex;
        gap: 15px;
        align-items: center;
    }

    .help-banner {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 25px;
        border-radius: 10px;
        margin-bottom: 25px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    }

    .help-banner h3 {
        margin: 0 0 15px 0;
        color: white;
        text-align: center;
    }

    .help-steps {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    .help-steps .step {
        background: rgba(255, 255, 255, 0.15);
        padding: 12px 15px;
        border-radius: 8px;
        border-left: 4px solid #ffd700;
    }

    .help-steps strong {
        color: #ffd700;
    }

    .status-badge {
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 0.9rem;
        font-weight: 600;
    }

    .status-badge.connected {
        background: #27ae60;
        color: white;
    }

    .status-badge.disconnected {
        background: #e74c3c;
        color: white;
    }

    .card {
        background: white;
        padding: 25px;
        border-radius: 10px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
    }

    .card h2 {
        margin-top: 0;
        color: #34495e;
    }

    .info-text {
        color: #7f8c8d;
        margin-bottom: 20px;
    }

    .settings-row {
        margin-top: 15px;
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .settings-row label {
        font-weight: 600;
        color: #34495e;
    }

    .presenting-indicator {
        display: flex;
        align-items: center;
        gap: 10px;
        background: #27ae60;
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        margin-bottom: 15px;
        font-weight: 600;
    }

    .pulse-dot {
        width: 12px;
        height: 12px;
        background: white;
        border-radius: 50%;
        animation: pulse 2s infinite;
    }

    @keyframes pulse {
        0%, 100% {
            opacity: 1;
            transform: scale(1);
        }
        50% {
            opacity: 0.5;
            transform: scale(1.2);
        }
    }

    #localPreview {
        width: 100%;
        max-width: 800px;
        border-radius: 8px;
        margin-bottom: 15px;
        border: 2px solid #e0e0e0;
    }

    .stats {
        display: flex;
        gap: 30px;
        padding: 15px;
        background: #ecf0f1;
        border-radius: 8px;
        font-weight: 600;
        color: #2c3e50;
    }

    .display-health {
        margin-top: 15px;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 8px;
    }

    .display-health h4 {
        margin: 0 0 10px 0;
        color: #2c3e50;
    }

    .display-item {
        padding: 10px;
        margin: 5px 0;
        background: white;
        border-radius: 5px;
        border-left: 4px solid #95a5a6;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .display-item.active {
        border-left-color: #27ae60;
    }

    .display-item.error {
        border-left-color: #e74c3c;
    }

    .display-status {
        font-size: 0.9rem;
        color: #7f8c8d;
    }

    .alert {
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
    }

    .alert-warning {
        background: #fff3cd;
        border: 1px solid #ffc107;
        color: #856404;
    }
</style>

<script src="https://unpkg.com/livekit-client/dist/livekit-client.min.js"></script>
<script>
let websocket = null;
let livekitRoom = null;
let screenTrack = null;
let screenSender = null;
let sessionId = null;
let frameRate = 10;
let qualityIndex = 0;
let normalStableCount = 0;
let bandwidthLock = false;
let lastOutboundBytes = null;
let lastOutboundTimestamp = null;
let lastBandwidthStatus = null;
let codecWarned = false;
let lastAppliedEncoding = null;
const presenterId = 'presenter_' + Math.random().toString(36).substr(2, 9);
const connectedDisplays = new Map(); // Track display health status

const QUALITY_LEVELS = [
    { maxBitrate: 4000000, maxFramerate: 15 },
    { maxBitrate: 3500000, maxFramerate: 12 },
    { maxBitrate: 3500000, maxFramerate: 10 }
];

const PROTECTED_MIN = {
    maxBitrate: 3500000,
    minFramerate: 10
};

const NORMAL_THRESHOLDS = {
    minBitrate: 1200000,
    minFramerate: 8,
    maxPacketLoss: 0.05
};

// Check browser compatibility
window.addEventListener('load', () => {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
        document.getElementById('compatibilityWarning').style.display = 'block';
        document.getElementById('startSharingBtn').disabled = true;
    }
    if (!window.livekit) {
        document.getElementById('compatibilityWarning').style.display = 'block';
        document.getElementById('compatibilityWarning').textContent = 'LiveKit client failed to load. Check network access.';
        document.getElementById('startSharingBtn').disabled = true;
    }
    loadSessions();
});

// Load sessions
async function loadSessions() {
    try {
        const sessions = await apiRequest('/admin/presenter/sessions');

        const select = document.getElementById('sessionSelect');
        sessions.forEach(session => {
            const option = document.createElement('option');
            option.value = session.id;
            option.textContent = `${session.name} (${session.status})`;
            select.appendChild(option);
        });
    } catch (error) {
        console.error('Failed to load sessions:', error);
        showAlert('Failed to load sessions', 'error');
    }
}

// Session selection
document.getElementById('sessionSelect').addEventListener('change', async (e) => {
    sessionId = e.target.value;
    if (sessionId) {
        await connectWebSocket();
    } else if (websocket) {
        websocket.close();
    }
});

// FPS selection
document.getElementById('fpsSelect').addEventListener('change', (e) => {
    frameRate = parseInt(e.target.value);
    applyEncodingSettings();
});

function getEffectiveEncoding() {
    const level = QUALITY_LEVELS[qualityIndex];
    return {
        maxBitrate: level.maxBitrate,
        maxFramerate: Math.min(level.maxFramerate, frameRate)
    };
}

function normalizeStats(reports) {
    const all = [];
    if (!reports) {
        return all;
    }
    const reportList = Array.isArray(reports) ? reports : [reports];
    for (const report of reportList) {
        if (!report) {
            continue;
        }
        report.forEach(stat => all.push(stat));
    }
    return all;
}

async function collectOutboundStats() {
    if (!livekitRoom) {
        return null;
    }
    const stats = normalizeStats(await livekitRoom.getStats());
    const outbound = stats.find(stat =>
        stat.type === 'outbound-rtp' &&
        (stat.kind === 'video' || stat.mediaType === 'video') &&
        !stat.isRemote
    );

    if (!outbound) {
        return null;
    }

    let codec = null;
    if (outbound.codecId) {
        const codecStat = stats.find(stat => stat.id === outbound.codecId);
        if (codecStat && codecStat.mimeType) {
            codec = codecStat.mimeType;
        }
    }

    if (codec && !codec.toLowerCase().includes('vp9') && !codecWarned) {
        codecWarned = true;
        console.warn('[LiveKit] Codec fallback detected:', codec);
        showAlert(`Codec fallback detected: ${codec}`, 'warning');
    }

    let bitrate = null;
    const now = Date.now();
    if (outbound.bytesSent != null) {
        if (lastOutboundBytes != null && lastOutboundTimestamp != null) {
            const bytesDelta = outbound.bytesSent - lastOutboundBytes;
            const timeDelta = (now - lastOutboundTimestamp) / 1000;
            if (timeDelta > 0) {
                bitrate = (bytesDelta * 8) / timeDelta;
            }
        }
        lastOutboundBytes = outbound.bytesSent;
        lastOutboundTimestamp = now;
    }

    return { bitrate, codec };
}

// Connect WebSocket
async function connectWebSocket() {
    if (websocket) {
        websocket.close();
    }

    const token = getAuthToken();
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}/ws/presenter/${sessionId}?token=${token}`;

    websocket = new WebSocket(wsUrl);

    websocket.onopen = () => {
        console.log('WebSocket connected');
        document.getElementById('connectionStatus').textContent = 'Connected';
        document.getElementById('connectionStatus').className = 'status-badge connected';
    };

    websocket.onclose = () => {
        console.log('WebSocket disconnected, attempting to reconnect...');
        document.getElementById('connectionStatus').textContent = 'Reconnecting...';
        document.getElementById('connectionStatus').className = 'status-badge disconnected';

        setTimeout(() => {
            if (sessionId) {
                console.log('Reconnecting WebSocket...');
                connectWebSocket();
            }
        }, 2000);
    };

    websocket.onerror = (error) => {
        console.error('WebSocket error:', error);
    };

    websocket.onmessage = async (event) => {
        const message = JSON.parse(event.data);
        console.log('WebSocket message:', message);

        if (message.event === 'display.status') {
            const displayId = message.display_id;
            connectedDisplays.set(displayId, {
                id: displayId,
                status: message.status,
                role: message.role,
                resolution: message.resolution,
                frameRate: message.frameRate,
                bitrate: message.bitrate,
                packetLoss: message.packetLoss,
                jitter: message.jitter,
                lastUpdate: Date.now()
            });
            updateDisplayHealth();
        }
    };
}

async function fetchLiveKitToken() {
    return await apiRequest('/admin/presenter/livekit-token', {
        method: 'POST',
        body: JSON.stringify({ session_id: parseInt(sessionId, 10) })
    });
}

async function setupLiveKit() {
    const tokenResponse = await fetchLiveKitToken();
    const room = new livekit.Room({
        adaptiveStream: false,
        dynacast: false,
        publishDefaults: {
            simulcast: false,
            videoCodec: 'vp9',
            scalabilityMode: 'L1T3',
            videoEncoding: getEffectiveEncoding()
        }
    });

    room.on('disconnected', () => {
        console.warn('[LiveKit] Disconnected');
        sendStatusUpdate();
    });

    await room.connect(tokenResponse.livekit_url, tokenResponse.token, { autoSubscribe: false });
    livekitRoom = room;
    return tokenResponse;
}

async function publishScreenTrack() {
    const tracks = await livekit.createLocalScreenTracks({ audio: false, video: true });
    screenTrack = tracks.find(track => track.kind === 'video');
    if (!screenTrack) {
        throw new Error('Screen capture track not available');
    }

    screenTrack.mediaStreamTrack.contentHint = 'detail';
    const settings = screenTrack.mediaStreamTrack.getSettings();

    await screenTrack.mediaStreamTrack.applyConstraints({
        frameRate: { ideal: frameRate, max: frameRate },
        width: { ideal: settings.width },
        height: { ideal: settings.height }
    });

    const preview = document.getElementById('localPreview');
    preview.srcObject = new MediaStream([screenTrack.mediaStreamTrack]);

    const publication = await livekitRoom.localParticipant.publishTrack(screenTrack, {
        simulcast: false,
        videoCodec: 'vp9',
        scalabilityMode: 'L1T3',
        videoEncoding: getEffectiveEncoding()
    });

    screenSender = publication.trackSender || publication.sender;
    await applyEncodingSettings();

    screenTrack.mediaStreamTrack.addEventListener('ended', () => {
        stopScreenShare();
    });
}

async function applyEncodingSettings() {
    if (!screenSender) {
        return;
    }
    const encoding = getEffectiveEncoding();
    if (bandwidthLock && lastAppliedEncoding) {
        encoding.maxBitrate = Math.min(encoding.maxBitrate, lastAppliedEncoding.maxBitrate);
        encoding.maxFramerate = Math.min(encoding.maxFramerate, lastAppliedEncoding.maxFramerate);
    }
    const parameters = screenSender.getParameters();
    if (!parameters.encodings || parameters.encodings.length === 0) {
        parameters.encodings = [{}];
    }
    parameters.encodings[0].maxBitrate = encoding.maxBitrate;
    parameters.encodings[0].maxFramerate = encoding.maxFramerate;
    parameters.encodings[0].scaleResolutionDownBy = 1.0;
    parameters.degradationPreference = 'maintain-resolution';

    try {
        await screenSender.setParameters(parameters);
        lastAppliedEncoding = {
            maxBitrate: encoding.maxBitrate,
            maxFramerate: encoding.maxFramerate
        };
        document.getElementById('currentFps').textContent = encoding.maxFramerate;
    } catch (error) {
        console.warn('[LiveKit] Failed to apply encoding settings:', error);
    }
}

function getDisplayGroups() {
    const protectedDisplays = [];
    const normalDisplays = [];
    for (const display of connectedDisplays.values()) {
        if (display.role === 'protected') {
            protectedDisplays.push(display);
        } else {
            normalDisplays.push(display);
        }
    }
    return { protectedDisplays, normalDisplays };
}

function protectedDisplaysHealthy(protectedDisplays) {
    if (protectedDisplays.length === 0) {
        return false;
    }
    return protectedDisplays.every(display =>
        (display.bitrate || 0) >= PROTECTED_MIN.maxBitrate &&
        (display.frameRate || 0) >= PROTECTED_MIN.minFramerate
    );
}

function normalDisplaysUnderPressure(normalDisplays) {
    return normalDisplays.some(display => {
        const bitrateOk = (display.bitrate || 0) >= NORMAL_THRESHOLDS.minBitrate;
        const fpsOk = (display.frameRate || 0) >= NORMAL_THRESHOLDS.minFramerate;
        const lossOk = (display.packetLoss || 0) <= NORMAL_THRESHOLDS.maxPacketLoss;
        return !(bitrateOk && fpsOk && lossOk);
    });
}

async function evaluateQuality() {
    if (!screenSender) {
        return;
    }
    const { protectedDisplays, normalDisplays } = getDisplayGroups();
    const protectedOk = protectedDisplaysHealthy(protectedDisplays);

    if (!protectedOk) {
        console.warn('[Quality] Protected displays below minimum threshold');
        return;
    }

    const underPressure = normalDisplaysUnderPressure(normalDisplays);
    if (underPressure && qualityIndex < QUALITY_LEVELS.length - 1) {
        qualityIndex += 1;
        normalStableCount = 0;
        await applyEncodingSettings();
        return;
    }

    if (!underPressure) {
        normalStableCount += 1;
    }

    if (!bandwidthLock && normalStableCount >= 3 && qualityIndex > 0) {
        qualityIndex -= 1;
        normalStableCount = 0;
        await applyEncodingSettings();
    }
}

// Start screen sharing
async function startScreenShare() {
    if (!sessionId) {
        showAlert('Please select a session first', 'error');
        return;
    }

    try {
        await setupLiveKit();
        await publishScreenTrack();

        document.getElementById('notPresentingState').style.display = 'none';
        document.getElementById('presentingState').style.display = 'block';

        if (websocket && websocket.readyState === WebSocket.OPEN) {
            websocket.send(JSON.stringify({
                action: 'start-presenting',
                presenter_id: presenterId
            }));
        }
    } catch (error) {
        console.error('Failed to start screen sharing:', error);
        showAlert('Failed to start screen sharing: ' + error.message, 'error');
        await stopScreenShare();
    }
}

// Stop screen sharing
async function stopScreenShare() {
    if (screenTrack) {
        screenTrack.stop();
        screenTrack = null;
    }

    if (livekitRoom) {
        await livekitRoom.disconnect();
        livekitRoom = null;
    }

    if (websocket && websocket.readyState === WebSocket.OPEN) {
        websocket.send(JSON.stringify({
            action: 'stop-presenting',
            presenter_id: presenterId
        }));
    }

    document.getElementById('notPresentingState').style.display = 'block';
    document.getElementById('presentingState').style.display = 'none';
    document.getElementById('localPreview').srcObject = null;
}

// Send status update to admin dashboard
async function sendStatusUpdate() {
    if (!websocket || websocket.readyState !== WebSocket.OPEN) {
        console.log('[Status] WebSocket not ready, skipping status update');
        return;
    }

    const outboundStats = await collectOutboundStats();
    const encoding = getEffectiveEncoding();
    const resolution = screenTrack
        ? `${screenTrack.mediaStreamTrack.getSettings().width}x${screenTrack.mediaStreamTrack.getSettings().height}`
        : null;

    const status = {
        action: 'status-update',
        presenter_id: presenterId,
        is_presenting: !!screenTrack,
        webrtc_state: livekitRoom ? livekitRoom.state : 'disconnected',
        frame_rate: encoding.maxFramerate,
        resolution: resolution,
        bitrate: outboundStats ? outboundStats.bitrate : null,
        codec: outboundStats ? outboundStats.codec : null,
        bitrate_cap: encoding.maxBitrate,
        fps_cap: encoding.maxFramerate,
        fec: true,
        rtx: true,
        bandwidth_locked: bandwidthLock
    };

    websocket.send(JSON.stringify(status));
}

async function refreshBandwidthStatus() {
    try {
        const status = await apiRequest('/admin/bandwidth/status');
        bandwidthLock = status.status === 'critical';
        if (bandwidthLock && screenSender) {
            applyEncodingSettings();
        }
        if (lastBandwidthStatus !== status.status) {
            lastBandwidthStatus = status.status;
            if (status.status === 'warn') {
                showAlert('Bandwidth warning: daily usage above 160 GB', 'warning');
            } else if (status.status === 'critical') {
                showAlert('Bandwidth critical: bitrate increases locked', 'error');
            }
        }
    } catch (error) {
        console.warn('[Bandwidth] Failed to fetch status:', error);
    }
}

// Send periodic status updates
setInterval(() => {
    if (screenTrack && livekitRoom) {
        sendStatusUpdate();
        evaluateQuality();
    }
}, 3000);

setInterval(() => {
    refreshBandwidthStatus();
}, 60000);

refreshBandwidthStatus();

// Update display health status UI
function updateDisplayHealth() {
    const healthList = document.getElementById('displayHealthList');
    const displayCount = document.getElementById('displayCount');

    if (!healthList) return;

    displayCount.textContent = connectedDisplays.size;

    const now = Date.now();
    for (const [id, display] of connectedDisplays.entries()) {
        if (now - display.lastUpdate > 15000) {
            connectedDisplays.delete(id);
        }
    }

    if (connectedDisplays.size === 0) {
        healthList.innerHTML = '<div class="display-status">No displays connected</div>';
        return;
    }

    healthList.innerHTML = '';
    for (const [id, display] of connectedDisplays.entries()) {
        const item = document.createElement('div');
        item.className = 'display-item';

        const role = display.role || 'pending';
        const statusText = display.status || 'pending';
        const details = display.resolution
            ? `${display.resolution} @ ${Math.round(display.frameRate || 0)} FPS`
            : '';
        const bitrateText = display.bitrate ? `${(display.bitrate / 1000000).toFixed(2)} Mbps` : '';

        const isProtected = role === 'protected';
        const hasError = display.packetLoss && display.packetLoss > NORMAL_THRESHOLDS.maxPacketLoss;

        if (display.status === 'connected') {
            item.classList.add('active');
        } else if (hasError) {
            item.classList.add('error');
        }

        item.innerHTML = `
            <div>
                <strong>${id.substring(0, 12)}...</strong>
                <div class="display-status">${statusText} (${role})</div>
                <div class="display-status">${details}${bitrateText ? ' - ' + bitrateText : ''}</div>
            </div>
            <div style="color: ${item.classList.contains('active') ? '#27ae60' : item.classList.contains('error') ? '#e74c3c' : '#95a5a6'}">
                ${isProtected ? '??' : '?'}
            </div>
        `;

        healthList.appendChild(item);
    }
}
</script>
{% endblock %}
