{% extends "base.html" %}

{% block title %}Presenter Dashboard - Quiz System{% endblock %}

{% block content %}
<div class="presenter-container">
    <div class="header">
        <h1>üé• Presenter Dashboard</h1>
        <div class="header-actions">
            <span id="connectionStatus" class="status-badge disconnected">Disconnected</span>
            <button onclick="logout()" class="btn btn-secondary">Logout</button>
        </div>
    </div>

    <!-- Session Selection -->
    <div class="card">
        <h2>Select Session</h2>
        <select id="sessionSelect" class="form-control">
            <option value="">-- Select a session --</option>
        </select>
    </div>

    <!-- Help Instructions -->
    <div class="help-banner">
        <h3>üìñ Quick Start Guide</h3>
        <div class="help-steps">
            <div class="step">1Ô∏è‚É£ Select your session above</div>
            <div class="step">2Ô∏è‚É£ Open your PowerPoint presentation in full-screen mode</div>
            <div class="step">3Ô∏è‚É£ Click "Start Screen Sharing" and select the presentation window</div>
            <div class="step">4Ô∏è‚É£ Navigate slides using PowerPoint controls - they'll appear on the main display!</div>
            <div class="step">üí° <strong>Tip:</strong> Use 10 FPS (recommended) for smooth presentation with good quality</div>
        </div>
    </div>

    <!-- Screen Sharing Controls -->
    <div class="card">
        <h2>Screen Sharing</h2>
        <div id="notPresentingState">
            <p class="info-text">Share your screen to present PowerPoint slides to the display</p>
            <button id="startSharingBtn" class="btn btn-primary" onclick="startScreenShare()">
                üì∫ Start Screen Sharing
            </button>
            <div class="settings-row">
                <label>Frame Rate:</label>
                <select id="fpsSelect">
                    <option value="5">5 FPS (Low bandwidth)</option>
                    <option value="10" selected>10 FPS (Recommended)</option>
                </select>
            </div>
        </div>

        <div id="presentingState" style="display: none;">
            <div class="presenting-indicator">
                <div class="pulse-dot"></div>
                <span>You are presenting</span>
            </div>
            <video id="localPreview" autoplay playsinline muted></video>
            <button id="stopSharingBtn" class="btn btn-danger" onclick="stopScreenShare()">
                ‚èπÔ∏è Stop Sharing
            </button>
            <div class="stats">
                <div>Frame Rate: <span id="currentFps">0</span> FPS</div>
                <div>Connected Displays: <span id="displayCount">0</span></div>
            </div>
            <div class="display-health">
                <h4>üì∫ Display Status</h4>
                <div id="displayHealthList"></div>
            </div>
        </div>
    </div>

    <!-- Browser Compatibility Warning -->
    <div id="compatibilityWarning" class="alert alert-warning" style="display: none;">
        ‚ö†Ô∏è Screen sharing is not supported in your browser. Please use Chrome, Firefox, or Edge.
    </div>
</div>

<style>
    .presenter-container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
    }

    .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 30px;
        padding-bottom: 20px;
        border-bottom: 2px solid #e0e0e0;
    }

    .header h1 {
        margin: 0;
        color: #2c3e50;
    }

    .header-actions {
        display: flex;
        gap: 15px;
        align-items: center;
    }

    .help-banner {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 25px;
        border-radius: 10px;
        margin-bottom: 25px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    }

    .help-banner h3 {
        margin: 0 0 15px 0;
        color: white;
        text-align: center;
    }

    .help-steps {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    .help-steps .step {
        background: rgba(255, 255, 255, 0.15);
        padding: 12px 15px;
        border-radius: 8px;
        border-left: 4px solid #ffd700;
    }

    .help-steps strong {
        color: #ffd700;
    }

    .status-badge {
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 0.9rem;
        font-weight: 600;
    }

    .status-badge.connected {
        background: #27ae60;
        color: white;
    }

    .status-badge.disconnected {
        background: #e74c3c;
        color: white;
    }

    .card {
        background: white;
        padding: 25px;
        border-radius: 10px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
    }

    .card h2 {
        margin-top: 0;
        color: #34495e;
    }

    .info-text {
        color: #7f8c8d;
        margin-bottom: 20px;
    }

    .settings-row {
        margin-top: 15px;
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .settings-row label {
        font-weight: 600;
        color: #34495e;
    }

    .presenting-indicator {
        display: flex;
        align-items: center;
        gap: 10px;
        background: #27ae60;
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        margin-bottom: 15px;
        font-weight: 600;
    }

    .pulse-dot {
        width: 12px;
        height: 12px;
        background: white;
        border-radius: 50%;
        animation: pulse 2s infinite;
    }

    @keyframes pulse {
        0%, 100% {
            opacity: 1;
            transform: scale(1);
        }
        50% {
            opacity: 0.5;
            transform: scale(1.2);
        }
    }

    #localPreview {
        width: 100%;
        max-width: 800px;
        border-radius: 8px;
        margin-bottom: 15px;
        border: 2px solid #e0e0e0;
    }

    .stats {
        display: flex;
        gap: 30px;
        padding: 15px;
        background: #ecf0f1;
        border-radius: 8px;
        font-weight: 600;
        color: #2c3e50;
    }

    .display-health {
        margin-top: 15px;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 8px;
    }

    .display-health h4 {
        margin: 0 0 10px 0;
        color: #2c3e50;
    }

    .display-item {
        padding: 10px;
        margin: 5px 0;
        background: white;
        border-radius: 5px;
        border-left: 4px solid #95a5a6;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .display-item.active {
        border-left-color: #27ae60;
    }

    .display-item.error {
        border-left-color: #e74c3c;
    }

    .display-status {
        font-size: 0.9rem;
        color: #7f8c8d;
    }

    .alert {
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
    }

    .alert-warning {
        background: #fff3cd;
        border: 1px solid #ffc107;
        color: #856404;
    }
</style>

<script>
let websocket = null;
let peerConnection = null;
let screenStream = null;
let sessionId = null;
let frameRate = 10;
const presenterId = 'presenter_' + Math.random().toString(36).substr(2, 9);
const connectedDisplays = new Map(); // Track display health status

// Check browser compatibility
window.addEventListener('load', () => {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
        document.getElementById('compatibilityWarning').style.display = 'block';
        document.getElementById('startSharingBtn').disabled = true;
    }
    loadSessions();
});

// Load sessions
async function loadSessions() {
    try {
        const sessions = await apiRequest('/admin/presenter/sessions');

        const select = document.getElementById('sessionSelect');
        sessions.forEach(session => {
            const option = document.createElement('option');
            option.value = session.id;
            option.textContent = `${session.name} (${session.status})`;
            select.appendChild(option);
        });
    } catch (error) {
        console.error('Failed to load sessions:', error);
        showAlert('Failed to load sessions', 'error');
    }
}

// Session selection
document.getElementById('sessionSelect').addEventListener('change', async (e) => {
    sessionId = e.target.value;
    if (sessionId) {
        await connectWebSocket();
    } else if (websocket) {
        websocket.close();
    }
});

// FPS selection
document.getElementById('fpsSelect').addEventListener('change', (e) => {
    frameRate = parseInt(e.target.value);
});

// Connect WebSocket
async function connectWebSocket() {
    if (websocket) {
        websocket.close();
    }

    const token = getAuthToken();
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}/ws/presenter/${sessionId}?token=${token}`;

    websocket = new WebSocket(wsUrl);

    websocket.onopen = () => {
        console.log('WebSocket connected');
        document.getElementById('connectionStatus').textContent = 'Connected';
        document.getElementById('connectionStatus').className = 'status-badge connected';
    };

    websocket.onclose = () => {
        console.log('WebSocket disconnected, attempting to reconnect...');
        document.getElementById('connectionStatus').textContent = 'Reconnecting...';
        document.getElementById('connectionStatus').className = 'status-badge disconnected';

        // Attempt to reconnect after 2 seconds
        setTimeout(() => {
            if (sessionId) {
                console.log('Reconnecting WebSocket...');
                connectWebSocket();
            }
        }, 2000);
    };

    websocket.onerror = (error) => {
        console.error('WebSocket error:', error);
    };

    websocket.onmessage = async (event) => {
        const message = JSON.parse(event.data);
        console.log('WebSocket message:', message);

        // Handle display ready (reconnection while presenting)
        if (message.event === 'display.ready') {
            console.log('[WebRTC] Display reconnected, re-sending offer');

            // Track new display
            const displayId = message.display_id;
            connectedDisplays.set(displayId, {
                id: displayId,
                status: 'connecting',
                lastUpdate: Date.now()
            });
            updateDisplayHealth();

            if (screenStream && peerConnection) {
                try {
                    // Re-create and send offer for the new display
                    const offer = await peerConnection.createOffer({
                        offerToReceiveAudio: false,
                        offerToReceiveVideo: false
                    });

                    offer.sdp = preferCodec(offer.sdp, 'video', 'VP9');
                    await peerConnection.setLocalDescription(offer);

                    if (websocket && websocket.readyState === WebSocket.OPEN) {
                        websocket.send(JSON.stringify({
                            type: 'offer',
                            sdp: offer.sdp,
                            presenter_id: presenterId
                        }));
                        console.log('[WebRTC] Offer re-sent to reconnected display');
                    }
                } catch (error) {
                    console.error('[WebRTC] Failed to re-send offer:', error);
                }
            }
        }

        // Handle display status updates (health checks)
        if (message.event === 'display.status') {
            const displayId = message.display_id;
            const status = message.status;

            connectedDisplays.set(displayId, {
                id: displayId,
                status: status,
                resolution: message.resolution,
                frameRate: message.frameRate,
                lastUpdate: Date.now()
            });

            updateDisplayHealth();
            console.log('[WebRTC] Display status update:', displayId, status);
        }

        // Handle WebRTC answer from display
        if (message.event === 'webrtc.answer') {
            await peerConnection.setRemoteDescription(new RTCSessionDescription({
                type: 'answer',
                sdp: message.sdp
            }));
        }

        // Handle ICE candidate from display
        if (message.event === 'webrtc.ice.display') {
            await peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate));
        }
    };
}

// Start screen sharing
async function startScreenShare() {
    if (!sessionId) {
        showAlert('Please select a session first', 'error');
        return;
    }

    try {
        // Get screen stream
        screenStream = await navigator.mediaDevices.getDisplayMedia({
            video: {
                cursor: 'always',
                displaySurface: 'window'
            },
            audio: false
        });

        // Show local preview
        document.getElementById('localPreview').srcObject = screenStream;

        // Setup WebRTC
        await setupWebRTC();

        // Show presenting state
        document.getElementById('notPresentingState').style.display = 'none';
        document.getElementById('presentingState').style.display = 'block';

        // Notify server
        if (websocket && websocket.readyState === WebSocket.OPEN) {
            websocket.send(JSON.stringify({
                action: 'start-presenting',
                presenter_id: presenterId
            }));
        }

        // Handle stream ending
        screenStream.getVideoTracks()[0].addEventListener('ended', () => {
            stopScreenShare();
        });

    } catch (error) {
        console.error('Failed to start screen sharing:', error);
        showAlert('Failed to start screen sharing: ' + error.message, 'error');
    }
}

// Helper function to prefer specific codec in SDP
function preferCodec(sdp, type, codec) {
    const lines = sdp.split('\r\n');
    const mLineIndex = lines.findIndex(line => line.startsWith(`m=${type}`));

    if (mLineIndex === -1) return sdp;

    // Find the codec payload type
    const codecPattern = new RegExp(`a=rtpmap:(\\d+) ${codec}\\/\\d+`, 'i');
    let codecPayload = null;

    for (let i = mLineIndex; i < lines.length; i++) {
        const match = lines[i].match(codecPattern);
        if (match) {
            codecPayload = match[1];
            break;
        }
        if (lines[i].startsWith('m=')) break;
    }

    if (!codecPayload) return sdp; // Codec not found

    // Move preferred codec to front of m-line
    const mLine = lines[mLineIndex].split(' ');
    const payloadIndex = mLine.indexOf(codecPayload);

    if (payloadIndex > 3) { // After m=video/audio port proto
        mLine.splice(payloadIndex, 1);
        mLine.splice(3, 0, codecPayload);
        lines[mLineIndex] = mLine.join(' ');
    }

    return lines.join('\r\n');
}

// Setup WebRTC peer connection
async function setupWebRTC() {
    // Create peer connection
    peerConnection = new RTCPeerConnection({
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' }
        ]
    });

    // Monitor connection state and send status updates
    peerConnection.onconnectionstatechange = () => {
        console.log('[WebRTC] Connection state:', peerConnection.connectionState);
        sendStatusUpdate();
    };

    peerConnection.oniceconnectionstatechange = () => {
        console.log('[WebRTC] ICE connection state:', peerConnection.iceConnectionState);
        sendStatusUpdate();
    };

    // Use original screen stream directly for maximum quality
    const videoTrack = screenStream.getVideoTracks()[0];

    // Get current settings
    const settings = videoTrack.getSettings();
    console.log(`Screen capture resolution: ${settings.width}x${settings.height}`);

    // Apply constraints to limit frame rate but maintain quality
    await videoTrack.applyConstraints({
        frameRate: { ideal: frameRate, max: frameRate },
        width: { ideal: settings.width },
        height: { ideal: settings.height }
    });

    // Add track to peer connection with maximum quality
    const sender = peerConnection.addTrack(videoTrack, screenStream);

    // Set encoding parameters for very high quality
    const parameters = sender.getParameters();
    if (!parameters.encodings || parameters.encodings.length === 0) {
        parameters.encodings = [{}];
    }

    // Set very high bitrate for excellent quality (5 Mbps max)
    parameters.encodings[0].maxBitrate = 5000000; // 5 Mbps for high quality
    parameters.encodings[0].maxFramerate = frameRate;
    parameters.encodings[0].scaleResolutionDownBy = 1.0; // No downscaling

    await sender.setParameters(parameters);

    console.log(`WebRTC encoding: ${frameRate} FPS, 5 Mbps max bitrate`);

    // Update FPS display
    document.getElementById('currentFps').textContent = frameRate;

    // Handle ICE candidates
    peerConnection.onicecandidate = (event) => {
        if (event.candidate && websocket && websocket.readyState === WebSocket.OPEN) {
            try {
                websocket.send(JSON.stringify({
                    type: 'ice-candidate',
                    candidate: event.candidate,
                    presenter_id: presenterId
                }));
            } catch (error) {
                console.error('[WebRTC] Failed to send ICE candidate:', error);
            }
        } else if (event.candidate) {
            console.warn('[WebRTC] Cannot send ICE candidate, WebSocket not ready');
        }
    };

    // Create and send offer with video quality constraints
    const offer = await peerConnection.createOffer({
        offerToReceiveAudio: false,
        offerToReceiveVideo: false
    });

    // Modify SDP to prefer VP9 codec for better compression
    offer.sdp = preferCodec(offer.sdp, 'video', 'VP9');

    await peerConnection.setLocalDescription(offer);

    if (websocket && websocket.readyState === WebSocket.OPEN) {
        try {
            websocket.send(JSON.stringify({
                type: 'offer',
                sdp: offer.sdp,
                presenter_id: presenterId
            }));
            console.log('[WebRTC] Offer sent successfully');
        } catch (error) {
            console.error('[WebRTC] Failed to send offer:', error);
            throw new Error('Failed to send WebRTC offer: WebSocket error');
        }
    } else {
        console.error('[WebRTC] Cannot send offer: WebSocket not connected');
        throw new Error('WebSocket not connected. Please wait for reconnection.');
    }
}

// Stop screen sharing
function stopScreenShare() {
    // Stop screen stream
    if (screenStream) {
        screenStream.getTracks().forEach(track => track.stop());
        screenStream = null;
    }

    // Close peer connection
    if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
    }

    // Notify server
    if (websocket && websocket.readyState === WebSocket.OPEN) {
        websocket.send(JSON.stringify({
            action: 'stop-presenting',
            presenter_id: presenterId
        }));
    }

    // Reset UI
    document.getElementById('notPresentingState').style.display = 'block';
    document.getElementById('presentingState').style.display = 'none';
    document.getElementById('localPreview').srcObject = null;
}

// Send status update to admin dashboard
function sendStatusUpdate() {
    if (!websocket || websocket.readyState !== WebSocket.OPEN) {
        console.log('[Status] WebSocket not ready, skipping status update');
        return;
    }

    try {
        const status = {
            action: 'status-update',
            presenter_id: presenterId,
            is_presenting: !!screenStream,
            webrtc_state: peerConnection ? peerConnection.connectionState : 'disconnected',
            ice_state: peerConnection ? peerConnection.iceConnectionState : 'disconnected',
            frame_rate: frameRate,
            resolution: screenStream ? `${screenStream.getVideoTracks()[0].getSettings().width}x${screenStream.getVideoTracks()[0].getSettings().height}` : null
        };

        websocket.send(JSON.stringify(status));
    } catch (error) {
        console.error('[Status] Failed to send status update:', error);
    }
}

// Send periodic status updates
setInterval(() => {
    if (screenStream && peerConnection) {
        sendStatusUpdate();
    }
}, 3000); // Every 3 seconds

// Update display health status UI
function updateDisplayHealth() {
    const healthList = document.getElementById('displayHealthList');
    const displayCount = document.getElementById('displayCount');

    if (!healthList) return;

    // Update count
    displayCount.textContent = connectedDisplays.size;

    // Clear old stale displays (no update in 15 seconds)
    const now = Date.now();
    for (const [id, display] of connectedDisplays.entries()) {
        if (now - display.lastUpdate > 15000) {
            connectedDisplays.delete(id);
        }
    }

    // Update display list
    if (connectedDisplays.size === 0) {
        healthList.innerHTML = '<div class="display-status">No displays connected</div>';
        return;
    }

    healthList.innerHTML = '';
    for (const [id, display] of connectedDisplays.entries()) {
        const item = document.createElement('div');
        item.className = 'display-item';

        if (display.status === 'video-healthy' || display.status === 'video-active') {
            item.classList.add('active');
        } else if (display.status === 'video-error') {
            item.classList.add('error');
        }

        const statusText = {
            'connecting': 'Connecting...',
            'video-playing': 'Video Starting',
            'video-active': 'Active',
            'video-healthy': 'Healthy',
            'video-error': 'Error',
            'video-stopped': 'Stopped'
        }[display.status] || display.status;

        const details = display.resolution
            ? `${display.resolution} @ ${Math.round(display.frameRate || 0)} FPS`
            : '';

        item.innerHTML = `
            <div>
                <strong>${id.substring(0, 12)}...</strong>
                <div class="display-status">${statusText}${details ? ' - ' + details : ''}</div>
            </div>
            <div style="color: ${item.classList.contains('active') ? '#27ae60' : item.classList.contains('error') ? '#e74c3c' : '#95a5a6'}">
                ${item.classList.contains('active') ? '‚óè' : item.classList.contains('error') ? '‚úï' : '‚óã'}
            </div>
        `;

        healthList.appendChild(item);
    }
}

// Clean up stale displays every 5 seconds
setInterval(() => {
    if (connectedDisplays.size > 0) {
        updateDisplayHealth();
    }
}, 5000);

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
    stopScreenShare();
    if (websocket) {
        websocket.close();
    }
});
</script>
{% endblock %}
